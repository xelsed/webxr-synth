<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR Immersive Audio Synthesizer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #0ff;
      overflow: hidden;
      position: relative;
    }
    
    #canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }
    
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      pointer-events: auto;
      min-width: 250px;
    }
    
    #hud h3 {
      margin: 0 0 10px 0;
      color: #f0f;
      text-shadow: 0 0 10px #f0f;
    }
    
    .hud-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      font-size: 14px;
    }
    
    .hud-value {
      color: #ff0;
      font-weight: bold;
    }
    
    #controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }
    
    .control-btn {
      padding: 15px 30px;
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 255, 0.2));
      border: 2px solid #0ff;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .control-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 30px rgba(0, 255, 255, 0.5);
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 255, 0.3));
    }
    
    .control-btn:active {
      transform: translateY(0);
    }
    
    .control-btn.active {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(255, 0, 255, 0.5));
      box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
    }
    
    #vr-button {
      position: absolute;
      bottom: 30px;
      right: 30px;
      padding: 15px 30px;
      background: linear-gradient(135deg, #f0f, #0ff);
      border: none;
      color: #000;
      font-size: 18px;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      pointer-events: auto;
      animation: pulse-vr 2s infinite;
    }
    
    @keyframes pulse-vr {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      text-align: center;
      animation: glow 1.5s ease-in-out infinite;
    }
    
    @keyframes glow {
      0%, 100% { text-shadow: 0 0 10px #0ff; }
      50% { text-shadow: 0 0 20px #0ff, 0 0 30px #f0f; }
    }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div id="ui-overlay">
    <div id="hud">
      <h3>WEBXR SYNTH</h3>
      <div class="hud-item">
        <span>FPS:</span>
        <span class="hud-value" id="fps">60</span>
      </div>
      <div class="hud-item">
        <span>BPM:</span>
        <span class="hud-value" id="bpm">120</span>
      </div>
      <div class="hud-item">
        <span>MODE:</span>
        <span class="hud-value" id="mode">AMBIENT</span>
      </div>
      <div class="hud-item">
        <span>PATTERN:</span>
        <span class="hud-value" id="pattern">EUCLIDEAN</span>
      </div>
      <div class="hud-item">
        <span>XR STATUS:</span>
        <span class="hud-value" id="xr-status">READY</span>
      </div>
    </div>
    
    <div id="controls">
      <button class="control-btn" id="play-btn">PLAY</button>
      <button class="control-btn" id="mode-btn">MODE</button>
      <button class="control-btn" id="pattern-btn">PATTERN</button>
      <button class="control-btn" id="tempo-btn">TEMPO</button>
      <button class="control-btn" id="visual-btn">VISUALS</button>
    </div>
    
    <button id="vr-button" class="hidden">ENTER VR</button>
  </div>
  
  <div id="loading">Initializing WebXR...</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    
    // Euclidean Rhythm Generator
    class EuclideanRhythm {
      static generate(steps, pulses) {
        if (pulses > steps) pulses = steps;
        if (pulses === 0) return new Array(steps).fill(0);
        
        let pattern = [];
        let counts = [];
        let remainders = [];
        
        let divisor = steps - pulses;
        remainders.push(pulses);
        
        let level = 0;
        while (remainders[level] > 1) {
          counts.push(Math.floor(divisor / remainders[level]));
          remainders.push(divisor % remainders[level]);
          divisor = remainders[level];
          level++;
        }
        
        counts.push(divisor);
        
        const build = (lev) => {
          if (lev === -1) {
            pattern.push(0);
          } else if (lev === -2) {
            pattern.push(1);
          } else {
            for (let i = 0; i < counts[lev]; i++) {
              build(lev - 1);
            }
            if (remainders[lev] !== 0) {
              build(lev - 2);
            }
          }
        };
        
        build(level);
        return pattern;
      }
    }
    
    // Advanced Audio Engine using Web Audio API
    class AdvancedAudioEngine {
      constructor() {
        this.isPlaying = false;
        this.bpm = 120;
        this.currentMode = 0;
        this.currentPattern = 0;
        
        this.modes = ['AMBIENT', 'TECHNO', 'DUBSTEP', 'TRANCE', 'EXPERIMENTAL'];
        this.patterns = ['EUCLIDEAN', 'RANDOM', 'SPIRAL', 'CHAOS', 'HARMONIC'];
        
        this.audioContext = null;
        this.oscillators = [];
        this.gainNodes = [];
        this.filters = [];
        this.analyzer = null;
        this.sequenceInterval = null;
        this.currentStep = 0;
        this.pattern = [];
      }
      
      async init() {
        // Initialize Web Audio API
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create analyzer with higher resolution
        this.analyzer = this.audioContext.createAnalyser();
        this.analyzer.fftSize = 512;
        this.analyzer.smoothingTimeConstant = 0.8;
        this.analyzer.connect(this.audioContext.destination);
        
        // Create master gain with compressor
        this.compressor = this.audioContext.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 30;
        this.compressor.ratio.value = 12;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        this.compressor.connect(this.analyzer);
        
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.7;
        this.masterGain.connect(this.compressor);
        
        // Create high-quality reverb
        this.convolver = this.audioContext.createConvolver();
        this.reverbGain = this.audioContext.createGain();
        this.reverbGain.gain.value = 0.4;
        this.convolver.connect(this.reverbGain);
        this.reverbGain.connect(this.masterGain);
        
        // Generate better reverb impulse
        const length = this.audioContext.sampleRate * 3;
        const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, 1.5);
            channelData[i] = (Math.random() * 2 - 1) * decay;
            // Add early reflections
            if (i < 1000) {
              channelData[i] *= 0.3;
            }
          }
        }
        this.convolver.buffer = impulse;
        
        // Create ping-pong delay
        this.delayLeft = this.audioContext.createDelay(1.0);
        this.delayRight = this.audioContext.createDelay(1.0);
        this.delayLeft.delayTime.value = 0.25;
        this.delayRight.delayTime.value = 0.375;
        
        this.delayGainLeft = this.audioContext.createGain();
        this.delayGainRight = this.audioContext.createGain();
        this.delayGainLeft.gain.value = 0.4;
        this.delayGainRight.gain.value = 0.4;
        
        // Cross-connect delays for ping-pong effect
        this.delayLeft.connect(this.delayGainLeft);
        this.delayGainLeft.connect(this.delayRight);
        this.delayRight.connect(this.delayGainRight);
        this.delayGainRight.connect(this.delayLeft);
        
        this.delayGainLeft.connect(this.masterGain);
        this.delayGainRight.connect(this.masterGain);
        
        // Create filter with LFO modulation
        this.filter = this.audioContext.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 2000;
        this.filter.Q.value = 5;
        this.filter.connect(this.masterGain);
        
        // Create LFO for filter modulation
        this.lfo = this.audioContext.createOscillator();
        this.lfoGain = this.audioContext.createGain();
        this.lfo.frequency.value = 0.5;
        this.lfoGain.gain.value = 800;
        this.lfo.connect(this.lfoGain);
        this.lfoGain.connect(this.filter.frequency);
        this.lfo.start();
        
        // Create distortion using waveshaper
        this.distortion = this.audioContext.createWaveShaper();
        this.distortion.curve = this.makeDistortionCurve(20);
        this.distortion.oversample = '4x';
        this.distortionGain = this.audioContext.createGain();
        this.distortionGain.gain.value = 0.2;
        this.distortion.connect(this.distortionGain);
        this.distortionGain.connect(this.masterGain);
        
        this.setupSequences();
      }
      
      makeDistortionCurve(amount) {
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        
        for (let i = 0; i < samples; i++) {
          const x = (i * 2) / samples - 1;
          curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
        }
        
        return curve;
      }
      
      setupSequences() {
        // Generate pattern based on current mode
        const mode = this.modes[this.currentMode];
        
        if (mode === 'AMBIENT') {
          this.pattern = this.generateAmbientPattern();
        } else if (mode === 'TECHNO') {
          this.pattern = this.generateTechnoPattern();
        } else if (mode === 'DUBSTEP') {
          this.pattern = this.generateDubstepPattern();
        } else if (mode === 'TRANCE') {
          this.pattern = this.generateTrancePattern();
        } else {
          this.pattern = this.generateExperimentalPattern();
        }
      }
      
      generateAmbientPattern() {
        // Ambient chord progression
        return [
          { notes: [261.63, 329.63, 392.00], type: 'pad' },
          { notes: [220.00, 277.18, 329.63], type: 'pad' },
          { notes: [196.00, 246.94, 293.66], type: 'pad' },
          { notes: [174.61, 220.00, 261.63], type: 'pad' }
        ];
      }
      
      generateTechnoPattern() {
        // Techno beat pattern using Euclidean rhythm
        const kickPattern = EuclideanRhythm.generate(16, 4);
        const hihatPattern = EuclideanRhythm.generate(16, 10);
        const bassPattern = [130.81, 130.81, 196.00, 130.81, 116.54, 116.54, 174.61, 130.81];
        
        return kickPattern.map((kick, i) => ({
          kick: kick,
          hihat: hihatPattern[i],
          bass: bassPattern[i % bassPattern.length],
          type: 'techno'
        }));
      }
      
      generateDubstepPattern() {
        // Dubstep wobble bass
        return [
          { notes: [65.41], type: 'wobble', lfo: 4 },
          { notes: [], type: 'silence' },
          { notes: [], type: 'silence' },
          { notes: [65.41], type: 'wobble', lfo: 8 },
          { notes: [], type: 'silence' },
          { notes: [98.00], type: 'wobble', lfo: 6 }
        ];
      }
      
      generateTrancePattern() {
        // Trance arpeggio
        const notes = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63];
        return notes.map(note => ({ notes: [note], type: 'arp' }));
      }
      
      generateExperimentalPattern() {
        // Random generative pattern
        return Array(16).fill(0).map(() => ({
          notes: Math.random() > 0.7 ? [
            100 + Math.random() * 400,
            150 + Math.random() * 300
          ] : [],
          type: 'experimental',
          random: Math.random()
        }));
      }
      
      playNote(frequency, type = 'sine', duration = 0.2) {
        const now = this.audioContext.currentTime;
        
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        // Add some detune for richness
        osc.type = type;
        osc.frequency.value = frequency;
        osc.detune.value = Math.random() * 10 - 5;
        
        // Better envelope
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.4, now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
        
        osc.connect(gain);
        
        // Route through effects based on type
        if (type === 'sawtooth') {
          // Bass through filter and distortion
          gain.connect(this.filter);
          gain.connect(this.distortion);
        } else if (type === 'square') {
          // Lead through delay
          gain.connect(this.delayLeft);
          gain.connect(this.masterGain);
        } else {
          // Pads through reverb
          gain.connect(this.convolver);
          gain.connect(this.masterGain);
        }
        
        osc.start(now);
        osc.stop(now + duration);
        
        // Add a second oscillator for richness
        if (type === 'sine' || type === 'sawtooth') {
          const osc2 = this.audioContext.createOscillator();
          const gain2 = this.audioContext.createGain();
          
          osc2.type = type;
          osc2.frequency.value = frequency * 1.01; // Slight detune
          osc2.detune.value = 7;
          
          gain2.gain.setValueAtTime(0, now);
          gain2.gain.linearRampToValueAtTime(0.2, now + 0.02);
          gain2.gain.exponentialRampToValueAtTime(0.01, now + duration);
          
          osc2.connect(gain2);
          gain2.connect(this.masterGain);
          
          osc2.start(now);
          osc2.stop(now + duration);
        }
      }
      
      playStep() {
        if (!this.isPlaying || !this.pattern || this.pattern.length === 0) return;
        
        const step = this.pattern[this.currentStep % this.pattern.length];
        
        if (step.notes && step.notes.length > 0) {
          step.notes.forEach(note => {
            const type = step.type === 'pad' ? 'sine' : 
                        step.type === 'techno' ? 'square' :
                        step.type === 'wobble' ? 'sawtooth' : 'sine';
            
            const duration = step.type === 'pad' ? 1.0 : 
                           step.type === 'wobble' ? 0.5 : 0.2;
            
            this.playNote(note, type, duration);
          });
        }
        
        // Handle techno mode drums
        if (step.type === 'techno') {
          if (step.kick) this.playNote(60, 'sine', 0.1);
          if (step.hihat) this.playNote(8000, 'square', 0.05);
          if (step.bass) this.playNote(step.bass, 'sawtooth', 0.15);
        }
        
        // Handle wobble bass LFO
        if (step.type === 'wobble' && step.lfo) {
          const lfo = this.audioContext.createOscillator();
          lfo.frequency.value = step.lfo;
          const lfoGain = this.audioContext.createGain();
          lfoGain.gain.value = 500;
          lfo.connect(lfoGain);
          lfoGain.connect(this.filter.frequency);
          lfo.start();
          lfo.stop(this.audioContext.currentTime + 0.5);
        }
        
        this.currentStep++;
      }
      
      async start() {
        if (!this.audioContext) {
          await this.init();
        }
        
        if (this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
        }
        
        this.isPlaying = true;
        this.currentStep = 0;
        
        // Calculate interval based on BPM
        const stepTime = 60000 / (this.bpm * 4); // 16th notes
        
        this.sequenceInterval = setInterval(() => {
          this.playStep();
        }, stepTime);
      }
      
      stop() {
        this.isPlaying = false;
        if (this.sequenceInterval) {
          clearInterval(this.sequenceInterval);
          this.sequenceInterval = null;
        }
      }
      
      changeMode() {
        this.currentMode = (this.currentMode + 1) % this.modes.length;
        const wasPlaying = this.isPlaying;
        if (wasPlaying) this.stop();
        this.setupSequences();
        if (wasPlaying) this.start();
        return this.modes[this.currentMode];
      }
      
      changePattern() {
        this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
        const wasPlaying = this.isPlaying;
        if (wasPlaying) this.stop();
        this.setupSequences();
        if (wasPlaying) this.start();
        return this.patterns[this.currentPattern];
      }
      
      changeTempo(delta) {
        this.bpm = Math.max(60, Math.min(200, this.bpm + delta));
        
        // Restart sequencer with new tempo if playing
        if (this.isPlaying) {
          this.stop();
          this.start();
        }
        
        return this.bpm;
      }
      
      getWaveform() {
        if (!this.analyzer) return new Float32Array(256);
        
        const dataArray = new Float32Array(this.analyzer.frequencyBinCount);
        this.analyzer.getFloatTimeDomainData(dataArray);
        return dataArray;
      }
      
      getLevel() {
        if (!this.analyzer) return 0;
        
        const dataArray = new Uint8Array(this.analyzer.frequencyBinCount);
        this.analyzer.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        
        return (sum / dataArray.length) / 255;
      }
    }
    
    // WebXR Synthesizer App
    class WebXRSynthApp {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        
        this.audio = new AdvancedAudioEngine();
        this.visualMode = 0;
        this.visualModes = ['PARTICLES', 'GEOMETRY', 'FRACTAL', 'WAVES', 'MATRIX'];
        
        this.xrSession = null;
        this.xrReferenceSpace = null;
        
        this.objects = {
          orb: null,
          particles: null,
          frequencyBars: [],
          environment: null,
          skybox: null
        };
        
        this.init();
      }
      
      async init() {
        try {
          this.setupRenderer();
          this.setupScene();
          this.setupLights();
          this.createEnvironment();
          this.createVisualizers();
          this.setupXR();
          this.setupEventListeners();
          await this.audio.init();
          
          document.getElementById('loading').classList.add('hidden');
          this.animate();
          
        } catch (error) {
          console.error('Initialization error:', error);
          document.getElementById('loading').textContent = 'Error: ' + error.message;
        }
      }
      
      setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({ 
          canvas: document.getElementById('canvas'),
          antialias: true,
          alpha: false,
          powerPreference: 'high-performance'
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        // Enable XR
        this.renderer.xr.enabled = true;
        
        // Set animation loop for XR
        this.renderer.setAnimationLoop((time, frame) => {
          this.render(time, frame);
        });
      }
      
      setupScene() {
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x000033, 0.02);
        
        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        this.camera.position.set(0, 1.6, 3);
        this.camera.lookAt(0, 0, 0);
      }
      
      setupLights() {
        // Ambient light
        const ambient = new THREE.AmbientLight(0x404040, 0.5);
        this.scene.add(ambient);
        
        // Main directional light
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 50;
        dirLight.shadow.camera.left = -10;
        dirLight.shadow.camera.right = 10;
        dirLight.shadow.camera.top = 10;
        dirLight.shadow.camera.bottom = -10;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        this.scene.add(dirLight);
        
        // Point lights for ambiance
        const colors = [0xff00ff, 0x00ffff, 0xffff00];
        colors.forEach((color, i) => {
          const light = new THREE.PointLight(color, 0.5, 10);
          light.position.set(
            Math.cos(i * Math.PI * 2 / 3) * 5,
            2,
            Math.sin(i * Math.PI * 2 / 3) * 5
          );
          this.scene.add(light);
        });
      }
      
      createEnvironment() {
        // Create floor
        const floorGeometry = new THREE.PlaneGeometry(50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x111111,
          metalness: 0.8,
          roughness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        this.scene.add(floor);
        
        // Create grid
        const grid = new THREE.GridHelper(50, 50, 0x00ffff, 0x003333);
        this.scene.add(grid);
        
        // Create skybox with stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 10000;
        const positions = new Float32Array(starsCount * 3);
        const colors = new Float32Array(starsCount * 3);
        
        for (let i = 0; i < starsCount * 3; i += 3) {
          const radius = 100 + Math.random() * 400;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          positions[i] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i + 2] = radius * Math.cos(phi);
          
          const color = new THREE.Color();
          color.setHSL(Math.random(), 0.7, 0.8);
          colors[i] = color.r;
          colors[i + 1] = color.g;
          colors[i + 2] = color.b;
        }
        
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const starsMaterial = new THREE.PointsMaterial({
          size: 0.5,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });
        
        this.objects.skybox = new THREE.Points(starsGeometry, starsMaterial);
        this.scene.add(this.objects.skybox);
      }
      
      createVisualizers() {
        // Main Orb
        const orbGeometry = new THREE.IcosahedronGeometry(1, 4);
        const orbMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x00ffff,
          emissive: 0x00ffff,
          emissiveIntensity: 0.5,
          metalness: 0.8,
          roughness: 0.2,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide
        });
        
        this.objects.orb = new THREE.Mesh(orbGeometry, orbMaterial);
        this.objects.orb.position.y = 1.5;
        this.objects.orb.castShadow = true;
        this.scene.add(this.objects.orb);
        
        // Inner orb with wireframe
        const innerGeometry = new THREE.IcosahedronGeometry(0.98, 4);
        const innerMaterial = new THREE.MeshBasicMaterial({
          color: 0xff00ff,
          wireframe: true,
          transparent: true,
          opacity: 0.5
        });
        const innerOrb = new THREE.Mesh(innerGeometry, innerMaterial);
        this.objects.orb.add(innerOrb);
        
        // Particle system (reduced for performance)
        const particleCount = 2500;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const radius = 3 + Math.random() * 7;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          
          particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          particlePositions[i3 + 2] = radius * Math.cos(phi);
          
          const color = new THREE.Color();
          color.setHSL(Math.random(), 1, 0.5);
          particleColors[i3] = color.r;
          particleColors[i3 + 1] = color.g;
          particleColors[i3 + 2] = color.b;
          
          particleSizes[i] = Math.random() * 0.1 + 0.05;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        
        const particleMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            audioLevel: { value: 0 }
          },
          vertexShader: `
            attribute float size;
            varying vec3 vColor;
            uniform float time;
            uniform float audioLevel;
            
            void main() {
              vColor = color;
              vec3 pos = position;
              pos += sin(time + position.x) * 0.1;
              pos += cos(time + position.y) * 0.1;
              pos *= 1.0 + audioLevel * 0.2;
              
              vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
              gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 + audioLevel);
              gl_Position = projectionMatrix * mvPosition;
            }
          `,
          fragmentShader: `
            varying vec3 vColor;
            
            void main() {
              vec2 center = gl_PointCoord - vec2(0.5);
              float dist = length(center);
              if (dist > 0.5) discard;
              
              float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
              gl_FragColor = vec4(vColor, alpha);
            }
          `,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          vertexColors: true
        });
        
        this.objects.particles = new THREE.Points(particleGeometry, particleMaterial);
        this.scene.add(this.objects.particles);
        
        // Frequency bars (circular arrangement - reduced to 16)
        const barCount = 16;
        const barGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
        
        for (let i = 0; i < barCount; i++) {
          const angle = (i / barCount) * Math.PI * 2;
          const radius = 4;
          
          const barMaterial = new THREE.MeshPhysicalMaterial({
            color: new THREE.Color().setHSL(i / barCount, 1, 0.5),
            emissive: new THREE.Color().setHSL(i / barCount, 1, 0.5),
            emissiveIntensity: 0.5,
            metalness: 0.8,
            roughness: 0.2
          });
          
          const bar = new THREE.Mesh(barGeometry, barMaterial);
          bar.position.x = Math.cos(angle) * radius;
          bar.position.z = Math.sin(angle) * radius;
          bar.position.y = 0.5;
          bar.castShadow = true;
          
          this.objects.frequencyBars.push(bar);
          this.scene.add(bar);
        }
      }
      
      setupXR() {
        // Check for WebXR support - prefer AR for Rokid glasses
        if ('xr' in navigator) {
          console.log('WebXR is available');
          
          // Check AR first (better for Rokid Max 2)
          navigator.xr.isSessionSupported('immersive-ar').then((arSupported) => {
            if (arSupported) {
              console.log('AR supported - using AR mode');
              const vrButton = document.getElementById('vr-button');
              vrButton.classList.remove('hidden');
              vrButton.textContent = 'ENTER AR';
              vrButton.addEventListener('click', () => this.startXRSession('immersive-ar'));
              document.getElementById('xr-status').textContent = 'AR READY';
              return;
            }
            
            // Fallback to VR if AR not supported
            navigator.xr.isSessionSupported('immersive-vr').then((vrSupported) => {
              if (vrSupported) {
                console.log('VR supported');
                const vrButton = document.getElementById('vr-button');
                vrButton.classList.remove('hidden');
                vrButton.textContent = 'ENTER VR';
                vrButton.addEventListener('click', () => this.startXRSession('immersive-vr'));
                document.getElementById('xr-status').textContent = 'VR READY';
              } else {
                document.getElementById('xr-status').textContent = 'XR NOT SUPPORTED';
              }
            });
          });
        } else {
          console.log('WebXR not available');
          document.getElementById('xr-status').textContent = 'NO XR';
        }
        
        // Setup XR controllers
        this.setupXRControllers();
      }
      
      setupXRControllers() {
        // Create controller grips
        this.controller1 = this.renderer.xr.getController(0);
        this.controller2 = this.renderer.xr.getController(1);
        
        this.scene.add(this.controller1);
        this.scene.add(this.controller2);
        
        // Create beam/ray for pointing
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -5)
        ]);
        
        const beamMaterial = new THREE.LineBasicMaterial({
          color: 0x00ffff,
          linewidth: 2,
          transparent: true,
          opacity: 0.8
        });
        
        this.beam1 = new THREE.Line(geometry, beamMaterial);
        this.beam2 = new THREE.Line(geometry, beamMaterial.clone());
        
        this.controller1.add(this.beam1);
        this.controller2.add(this.beam2);
        
        // Add controller event listeners
        this.controller1.addEventListener('selectstart', () => this.onSelectStart(this.controller1));
        this.controller1.addEventListener('selectend', () => this.onSelectEnd(this.controller1));
        this.controller2.addEventListener('selectstart', () => this.onSelectStart(this.controller2));
        this.controller2.addEventListener('selectend', () => this.onSelectEnd(this.controller2));
        
        // Add grip controllers for hand models
        const controllerGrip1 = this.renderer.xr.getControllerGrip(0);
        const controllerGrip2 = this.renderer.xr.getControllerGrip(1);
        
        this.scene.add(controllerGrip1);
        this.scene.add(controllerGrip2);
      }
      
      onSelectStart(controller) {
        // Trigger audio or visual change on controller select
        if (!this.audio.isPlaying) {
          this.audio.start();
          document.getElementById('play-btn').textContent = 'STOP';
        } else {
          this.audio.changeMode();
        }
        
        // Visual feedback
        const beam = controller === this.controller1 ? this.beam1 : this.beam2;
        if (beam && beam.material) {
          beam.material.color.setHex(0xff00ff);
          beam.material.opacity = 1.0;
        }
      }
      
      onSelectEnd(controller) {
        // Reset beam color
        const beam = controller === this.controller1 ? this.beam1 : this.beam2;
        if (beam && beam.material) {
          beam.material.color.setHex(0x00ffff);
          beam.material.opacity = 0.8;
        }
      }
      
      async startXRSession(mode) {
        try {
          console.log('Starting XR session:', mode);
          
          // Request XR session with required features
          const sessionInit = {
            requiredFeatures: ['local'],
            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers']
          };
          
          const session = await navigator.xr.requestSession(mode, sessionInit);
          this.xrSession = session;
          
          console.log('XR session started:', session);
          
          // Set the session
          this.renderer.xr.setSession(session);
          
          // Get reference space
          const referenceSpace = await session.requestReferenceSpace('local');
          this.xrReferenceSpace = referenceSpace;
          
          // Update button
          const vrButton = document.getElementById('vr-button');
          vrButton.textContent = mode === 'immersive-ar' ? 'EXIT AR' : 'EXIT VR';
          vrButton.onclick = () => this.endXRSession();
          
          // Hide regular controls in VR
          document.getElementById('controls').style.display = 'none';
          document.getElementById('hud').style.display = 'none';
          
          // Position camera for VR
          this.camera.position.set(0, 1.6, 0);
          
          // Handle session end
          session.addEventListener('end', () => {
            console.log('XR session ended');
            this.xrSession = null;
            this.renderer.xr.setSession(null);
            
            vrButton.textContent = 'ENTER VR';
            vrButton.onclick = () => this.startXRSession('immersive-vr');
            
            document.getElementById('controls').style.display = 'flex';
            document.getElementById('hud').style.display = 'block';
            
            // Reset camera position
            this.camera.position.set(0, 1.6, 3);
          });
          
          console.log('XR session fully initialized');
          
        } catch (error) {
          console.error('Failed to start XR session:', error);
          document.getElementById('xr-status').textContent = 'XR ERROR: ' + error.message;
          
          // Try inline session as fallback
          if (mode === 'immersive-vr') {
            console.log('Trying inline session as fallback...');
            try {
              const inlineSession = await navigator.xr.requestSession('inline');
              console.log('Inline session started:', inlineSession);
              document.getElementById('xr-status').textContent = 'INLINE MODE';
            } catch (inlineError) {
              console.error('Inline session also failed:', inlineError);
            }
          }
        }
      }
      
      endXRSession() {
        if (this.xrSession) {
          this.xrSession.end();
        }
      }
      
      setupEventListeners() {
        // Play/Stop
        document.getElementById('play-btn').addEventListener('click', async () => {
          if (this.audio.isPlaying) {
            this.audio.stop();
            document.getElementById('play-btn').textContent = 'PLAY';
            document.getElementById('play-btn').classList.remove('active');
          } else {
            await this.audio.start();
            document.getElementById('play-btn').textContent = 'STOP';
            document.getElementById('play-btn').classList.add('active');
          }
        });
        
        // Change mode
        document.getElementById('mode-btn').addEventListener('click', () => {
          const newMode = this.audio.changeMode();
          document.getElementById('mode').textContent = newMode;
        });
        
        // Change pattern
        document.getElementById('pattern-btn').addEventListener('click', () => {
          const newPattern = this.audio.changePattern();
          document.getElementById('pattern').textContent = newPattern;
        });
        
        // Change tempo
        document.getElementById('tempo-btn').addEventListener('click', () => {
          const newBPM = this.audio.changeTempo(10);
          document.getElementById('bpm').textContent = newBPM;
        });
        
        // Change visuals
        document.getElementById('visual-btn').addEventListener('click', () => {
          this.visualMode = (this.visualMode + 1) % this.visualModes.length;
          this.updateVisualMode();
        });
        
        // Window resize
        window.addEventListener('resize', () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Keyboard controls
        window.addEventListener('keydown', (e) => {
          switch(e.key) {
            case ' ':
              document.getElementById('play-btn').click();
              break;
            case 'm':
              document.getElementById('mode-btn').click();
              break;
            case 'p':
              document.getElementById('pattern-btn').click();
              break;
            case 'ArrowUp':
              this.audio.changeTempo(5);
              document.getElementById('bpm').textContent = this.audio.bpm;
              break;
            case 'ArrowDown':
              this.audio.changeTempo(-5);
              document.getElementById('bpm').textContent = this.audio.bpm;
              break;
          }
        });
      }
      
      updateVisualMode() {
        const mode = this.visualModes[this.visualMode];
        
        // Reset visibility
        this.objects.particles.visible = mode === 'PARTICLES';
        this.objects.frequencyBars.forEach(bar => bar.visible = mode !== 'MATRIX');
        
        // Apply mode-specific changes
        switch(mode) {
          case 'GEOMETRY':
            this.objects.orb.material.wireframe = false;
            break;
          case 'FRACTAL':
            this.objects.orb.material.wireframe = true;
            break;
          case 'WAVES':
            // Wave distortion handled in animation
            break;
          case 'MATRIX':
            // Matrix rain effect
            break;
        }
      }
      
      render(time, frame) {
        const deltaTime = this.clock.getDelta();
        const elapsedTime = this.clock.getElapsedTime();
        
        // Update FPS only if HUD is visible
        const fpsElement = document.getElementById('fps');
        if (fpsElement) {
          fpsElement.textContent = Math.round(1 / deltaTime);
        }
        
        // Get audio data
        const waveform = this.audio.getWaveform();
        const level = this.audio.getLevel();
        
        // Animate main orb
        if (this.objects.orb) {
          this.objects.orb.rotation.x += deltaTime * 0.5;
          this.objects.orb.rotation.y += deltaTime * 0.3;
          
          const scale = 1 + level * 0.5;
          this.objects.orb.scale.set(scale, scale, scale);
          
          // Color based on audio
          const hue = (elapsedTime * 0.1 + level) % 1;
          this.objects.orb.material.color.setHSL(hue, 1, 0.5);
          this.objects.orb.material.emissive.setHSL(hue, 1, 0.5);
        }
        
        // Animate particles
        if (this.objects.particles) {
          this.objects.particles.rotation.y += deltaTime * 0.1;
          this.objects.particles.material.uniforms.time.value = elapsedTime;
          this.objects.particles.material.uniforms.audioLevel.value = level;
        }
        
        // Animate frequency bars
        this.objects.frequencyBars.forEach((bar, i) => {
          const freqIndex = Math.floor((i / this.objects.frequencyBars.length) * waveform.length);
          const freqValue = Math.abs(waveform[freqIndex]) || 0;
          
          bar.scale.y = 0.1 + freqValue * 5;
          bar.position.y = bar.scale.y / 2;
          
          // Color based on frequency
          const hue = (i / this.objects.frequencyBars.length + elapsedTime * 0.1) % 1;
          bar.material.color.setHSL(hue, 1, 0.5 + freqValue * 0.5);
          bar.material.emissiveIntensity = freqValue;
        });
        
        // Animate skybox
        if (this.objects.skybox) {
          this.objects.skybox.rotation.y += deltaTime * 0.01;
        }
        
        // Render scene (renderer will use XR camera if in XR session)
        this.renderer.render(this.scene, this.camera);
      }
      
      animate() {
        // Animation loop is handled by renderer.setAnimationLoop in setupRenderer
        // This ensures it works for both regular and XR rendering
      }
    }
    
    // Initialize app
    const app = new WebXRSynthApp();
  </script>
</body>
</html>